// CodingGames.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <deque>
#include <iterator>
#include <chrono>
#include <map>
#include <stack>

using namespace std;

struct pair_hash
{
    template <typename T1, typename T2>
    std::size_t operator() (const std::pair<T1, T2>& pair) const {
        return std::hash<T1>()(pair.first) ^ std::hash<T2>()(pair.second);
    }
};

template<typename T>
class RollerCoaster
{
public:
    RollerCoaster(int n): totalEarnings(0){ container.resize(n); }
    RollerCoaster(T& newContainer):totalEarnings(0) { container = move(newContainer); }
    void AssignGroup(int i, int n)
    {
        container[i] = n;
    }
    void AddGroup(int quantity)
    {
        container.push_back(quantity);
    }
    void ShowQueue()
    {
        copy(container.begin(), container.end(), ostream_iterator<int>(cerr, " "));
        cerr << endl;
    }
    void RunRoll(int l, int c, int n);
    long long GetTotatlEarnings() { return totalEarnings; }
    bool StartIndexExist(map<pair<int, int>, int>& memTable, int startInd)
    {
        return find_if(memTable.begin(), memTable.end(), [&](const std::pair<pair<int, int>, int>& elem)
            {return elem.first.first == startInd; }) == memTable.end();
    }
private:
    long long totalEarnings;
    T container;
};

template<typename T>
void RollerCoaster<T>::RunRoll(int l, int c, int n)
{
    int ind = 0;
    int cnt = 0;
    while (c != 0)
    {
        int amountCurrRide = 0;
        cnt = 0;
        while (1)
        {
            if (amountCurrRide + container[0] <= l && cnt < n)
            {
                amountCurrRide += container[0];
                container.push_back(container[0]);
                container.pop_front();
                cnt++;
                ++ind;
                if (ind == n - 1)
                    ind = 0;
            }
            else
                break;
        }
        totalEarnings += amountCurrRide;
        c--;
    }
}

template<>
void RollerCoaster<vector<int>>::RunRoll(int l, int c, int n)
{
    map<int,pair<long long, long long>> memTable;//for memoization. each pair will point to sum for elements between pair.first and pair.second indexes
    vector<pair<int, long long>> vp;
    int ind = 0;
    int cnt = 0;
    int startInd = 0;
    long long res = 0;
    while (c != 0)
    {
        int amountCurrRide = 0;
        cnt = 0;
        startInd = ind;
        auto it = find_if(vp.begin(), vp.end(), [&](auto& el) {return el.first == startInd; });
        if (it != vp.end())
        {
            long long d = distance(it, vp.end());
            long long cntRange = c / d;
            int restC = c % d;
            long long delta = totalEarnings - memTable[it->first].second + memTable[it->first].first;
            auto endIt = it + restC;
            res = delta * cntRange;
            if (restC)
                res += (memTable[endIt->first].second - memTable[endIt->first].first) - (memTable[startInd].second - memTable[startInd].first);
            totalEarnings += res;
            break;
        }
        while (cnt < n)
        {
            amountCurrRide += container[ind];
            if (amountCurrRide > l)
            {
                amountCurrRide -= container[ind];
                break;
            }
            ind++;
            if (ind >= n)
                ind = 0;
            cnt++;
        }
        totalEarnings += amountCurrRide;
        vp.push_back(make_pair(startInd, amountCurrRide));
        memTable[startInd] = make_pair(amountCurrRide, totalEarnings);
        c--;
    }
}

int main()
{
    int l = 10;
    int c = 500;
    int n = 10;
    //deque<int> newDeq = { 4,6,5,3,3,8,4,5,8,5,5,6,4,4,5,4,6,4,10,6,1,1,10,1,1,5,10,7,3,9,4,8,7,10,10,9,7,6,5,6,2,9,1,5,5,7,1,10,10,2,7,3,4,7,3,4,3,5,2,6,5,5,3,3,5,5,4,3,10,8,9,3,7,1,10,1,10,2,2,9,3,8,3,8,6,6,2,9,2,5,6,6,10,8,9,6,4,2,8,5,9,8,8,7,1,9,9,10,10,10,10,4,10,3,1,7,10,4,7,1,9,2,6,8,2,6,5,7,7,2,2,8,2,1,6,2,9,5,3,10,4,2,3,3,6,3,2,5,7,8,5,7,2,1,4,3,8,10,9,5,3,2,4,4,2,9,7,2,3,9,1,9,1,3,3,6,8,4,3,4,2,7,2,3,9,7,7,7,6,7,3,8,9,6,4,2,6,10,4,1,9,4,9,1,7,1,8,4,5,10,9,8,9,10,10,7,8,8,3,3,4,5,10,2,2,3,4,10,3,7,10,3,2,8,5,10,10,2,5,4,4,5,1,2,6,2,8,3,9,3,5,3,9,5,6,3,9,1,2,3,9,3,5,1,10,1,10,9,5,5,5,8,9,7,1,5,9,8,7,9,2,4,1,1,8,9,5,8,9,6,1,8,10,7,8,9,8,9,9,2,5,5,1,4,2,1,10,10,10,8,8,2,1,1,4,10,9,10,8,9,7,10,6,6,8,5,4,5,6,4,8,10,9,10,3,10,10,4,1,10,2,8,3,4,10,8,4,10,9,3,9,5,2,6,10,1,3,5,8,8,8,5,7,8,5,2,9,6,5,9,7,8,9,1,2,10,10,7,10,8,9,10,2,2,5,1,2,7,5,9,4,5,6,3,4,2,4,5,7,8,3,4,8,3,6,9,3,6,7,4,3,5,3,5,8,7,5,9,6,2,10,1,8,5,3,3,8,6,7,4,6,2,9,3,4,5,3,8,10,9,3,2,5,5,8,2,4,5,2,9,6,1,9,5,7,2,7,4,9,6,8,4,7,8,6,2,4,10,10,3,8,2,7,2,9,4,5,2,8,7,2,5,7,2,1,4,3,10,9,2,5,8,7,1,6,5,4,9,4,3,4,4,7,2,7,7,7,2,8,7,10,1,3,6,2,4,1,7,5,10,10,9,9,6,1,6,10,6,7,6,9,10,9,7,3,7,3,9,10,2,7,9,4,10,5,5,5,7,1,9,8,10,9,7,8,1,4,7,6,10,4,6,1,4,4,3,1,8,4,10,9,2,1,4,1,7,9,7,3,1,7,3,3,7,1,10,9,4,8,5,4,2,2,4,5,8,9,7,5,4,9,6,5,9,9,8,5,9,6,9,10,3,3,2,9,3,3,8,7,10,4,2,3,7,7,10,4,7,6,9,2,4,4,7,4,4,6,10,3,1,9,2,5,1,5,6,6,7,3,4,8,8,5,1,6,3,2,10,2,7,10,3,3,5,9,8,8,6,8,10,9,8,3,3,10,7,8,5,5,2,8,5,1,4,7,7,9,8,6,10,6,5,2,8,1,3,8,8,10,5,10,8,4,2,3,3,1,10,10,7,4,9,1,6,5,7,2,3,4,9,4,10,5,7,9,5,1,6,3,1,2,4,8,5,5,2,8,5,4,9,2,7,7,4,4,1,1,6,5,6,6,8,5,3,7,6,7,7,3,1,7,5,4,7,9,1,8,8,7,1,6,10,9,5,4,3,5,4,10,2,1,7,1,8,9,7,3,6,4,5,8,10,9,4,8,10,4,8,9,10,8,5,10,9,1,5,3,7,8,4,8,10,10,9,7,9,7,9,6,10,6,3,2,4,6,1,5,1,8,4,1,8,10,2,6,10,6,10,6,5,3,6,4,2,6,1,10,2,1,7,2,6,10,5,2,7,5,6,8,3,9,10,10,8,3,7,9,8,6,5,4,10,2,9,1,7,9,3,8,2,1,1,7,10,5,8,9,2,4,8,6,4,9,7,4,1,5,2,10,10,8,3,1,9,3,3,7,2,7,5,3,8,5,1,9,2,9,7,5,4,4,10,9,4,6,2,4,2,6,5,1,5,9,3,6,2,5,2,5,2,8,9,9,3,9,7,6,9,6,10,4,1,1,3,5,8,6,10,9,3,5,1,8,3,3,5,4,7,6,8,10,4,6,8,8,7,7,5,5,2,4,9,4,6,3,8,3,8,8,3,1,2,3,8,6,5,4,10,3,9 };
    //vector<int> newVec = { 4,6,5,3,3,8,4,5,8,5,5,6,4,4,5,4,6,4,10,6,1,1,10,1,1,5,10,7,3,9,4,8,7,10,10,9,7,6,5,6,2,9,1,5,5,7,1,10,10,2,7,3,4,7,3,4,3,5,2,6,5,5,3,3,5,5,4,3,10,8,9,3,7,1,10,1,10,2,2,9,3,8,3,8,6,6,2,9,2,5,6,6,10,8,9,6,4,2,8,5,9,8,8,7,1,9,9,10,10,10,10,4,10,3,1,7,10,4,7,1,9,2,6,8,2,6,5,7,7,2,2,8,2,1,6,2,9,5,3,10,4,2,3,3,6,3,2,5,7,8,5,7,2,1,4,3,8,10,9,5,3,2,4,4,2,9,7,2,3,9,1,9,1,3,3,6,8,4,3,4,2,7,2,3,9,7,7,7,6,7,3,8,9,6,4,2,6,10,4,1,9,4,9,1,7,1,8,4,5,10,9,8,9,10,10,7,8,8,3,3,4,5,10,2,2,3,4,10,3,7,10,3,2,8,5,10,10,2,5,4,4,5,1,2,6,2,8,3,9,3,5,3,9,5,6,3,9,1,2,3,9,3,5,1,10,1,10,9,5,5,5,8,9,7,1,5,9,8,7,9,2,4,1,1,8,9,5,8,9,6,1,8,10,7,8,9,8,9,9,2,5,5,1,4,2,1,10,10,10,8,8,2,1,1,4,10,9,10,8,9,7,10,6,6,8,5,4,5,6,4,8,10,9,10,3,10,10,4,1,10,2,8,3,4,10,8,4,10,9,3,9,5,2,6,10,1,3,5,8,8,8,5,7,8,5,2,9,6,5,9,7,8,9,1,2,10,10,7,10,8,9,10,2,2,5,1,2,7,5,9,4,5,6,3,4,2,4,5,7,8,3,4,8,3,6,9,3,6,7,4,3,5,3,5,8,7,5,9,6,2,10,1,8,5,3,3,8,6,7,4,6,2,9,3,4,5,3,8,10,9,3,2,5,5,8,2,4,5,2,9,6,1,9,5,7,2,7,4,9,6,8,4,7,8,6,2,4,10,10,3,8,2,7,2,9,4,5,2,8,7,2,5,7,2,1,4,3,10,9,2,5,8,7,1,6,5,4,9,4,3,4,4,7,2,7,7,7,2,8,7,10,1,3,6,2,4,1,7,5,10,10,9,9,6,1,6,10,6,7,6,9,10,9,7,3,7,3,9,10,2,7,9,4,10,5,5,5,7,1,9,8,10,9,7,8,1,4,7,6,10,4,6,1,4,4,3,1,8,4,10,9,2,1,4,1,7,9,7,3,1,7,3,3,7,1,10,9,4,8,5,4,2,2,4,5,8,9,7,5,4,9,6,5,9,9,8,5,9,6,9,10,3,3,2,9,3,3,8,7,10,4,2,3,7,7,10,4,7,6,9,2,4,4,7,4,4,6,10,3,1,9,2,5,1,5,6,6,7,3,4,8,8,5,1,6,3,2,10,2,7,10,3,3,5,9,8,8,6,8,10,9,8,3,3,10,7,8,5,5,2,8,5,1,4,7,7,9,8,6,10,6,5,2,8,1,3,8,8,10,5,10,8,4,2,3,3,1,10,10,7,4,9,1,6,5,7,2,3,4,9,4,10,5,7,9,5,1,6,3,1,2,4,8,5,5,2,8,5,4,9,2,7,7,4,4,1,1,6,5,6,6,8,5,3,7,6,7,7,3,1,7,5,4,7,9,1,8,8,7,1,6,10,9,5,4,3,5,4,10,2,1,7,1,8,9,7,3,6,4,5,8,10,9,4,8,10,4,8,9,10,8,5,10,9,1,5,3,7,8,4,8,10,10,9,7,9,7,9,6,10,6,3,2,4,6,1,5,1,8,4,1,8,10,2,6,10,6,10,6,5,3,6,4,2,6,1,10,2,1,7,2,6,10,5,2,7,5,6,8,3,9,10,10,8,3,7,9,8,6,5,4,10,2,9,1,7,9,3,8,2,1,1,7,10,5,8,9,2,4,8,6,4,9,7,4,1,5,2,10,10,8,3,1,9,3,3,7,2,7,5,3,8,5,1,9,2,9,7,5,4,4,10,9,4,6,2,4,2,6,5,1,5,9,3,6,2,5,2,5,2,8,9,9,3,9,7,6,9,6,10,4,1,1,3,5,8,6,10,9,3,5,1,8,3,3,5,4,7,6,8,10,4,6,8,8,7,7,5,5,2,4,9,4,6,3,8,3,8,8,3,1,2,3,8,6,5,4,10,3,9 };
    vector<int> newVec = { 10,9,10,9, 10,9, 10,9, 10,9, };
    cerr << "l = " << l << endl;
    cerr << "c = " << c << endl;
    cerr << "n = " << n << endl;
    //RollerCoaster<deque<int>> rc(newDeq);
    RollerCoaster<vector<int>> rc(newVec);
    rc.ShowQueue();
    auto start_time = std::chrono::high_resolution_clock::now();
    rc.RunRoll(l, c, n);
    auto elapsed = std::chrono::high_resolution_clock::now() - start_time;
    long long microseconds = std::chrono::duration_cast<std::chrono::microseconds>(
        elapsed).count();
    std::cout << "Elapsed time " << microseconds << " mcs to run.\n";

    // Write an answer using cout. DON'T FORGET THE "<< endl"
    // To debug: cerr << "Debug messages..." << endl;

    cout << rc.GetTotatlEarnings() << endl;
}

// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
